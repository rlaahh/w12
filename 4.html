<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reframed</title>
    <style>
        body {
            /* ìˆ˜ì§ ì •ë ¬ì„ ìœ„í•´ flexbox ì‚¬ìš© */
            display: flex; 
            flex-direction: column; /* ì„¸ë¡œë¡œ ë°°ì¹˜ */
            align-items: center; /* ê°€ìš´ë° ì •ë ¬ */
            min-height: 100vh;
            background: #ffffff;
            margin: 0;
            position: relative;
        }
        
        /* Three.js ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼ ìˆ˜ì • (ë°˜ì‘í˜• ì ìš©) */
        #three-container {
            position: relative; 
            top: 0;
            left: 0;
            transform: none; 
            width: 80vw; /* ìŠ¬ë¼ì´ë”ì™€ ë™ì¼í•˜ê²Œ 80vwë¡œ ì„¤ì • */
            max-width: 800px; /* ìŠ¬ë¼ì´ë”ì™€ ë™ì¼í•˜ê²Œ 800pxë¡œ ì„¤ì • */
            
            /* ğŸ’¡ ìˆ˜ì •: ê³ ì •ëœ height ëŒ€ì‹  aspect-ratioë¥¼ ì‚¬ìš©í•˜ì—¬ ë°˜ì‘í˜• ë†’ì´ ì ìš© (ì˜ˆ: 4:1 ë¹„ìœ¨) */
            aspect-ratio: 4 / 1; 
            height: auto; 
            
            z-index: 10;
            margin-top: 20px; /* ìƒë‹¨ ì—¬ë°± */
            margin-bottom: 0px; /* ìŠ¬ë¼ì´ë”ì™€ì˜ ê°„ê²© */
        }

        /* ğŸ’¡ ì¶”ê°€: Three.js ìº”ë²„ìŠ¤ê°€ ë¶€ëª¨ ì»¨í…Œì´ë„ˆì˜ 100%ë¥¼ ì°¨ì§€í•˜ë„ë¡ ëª…ì‹œì  ì„¤ì • */
        #three-container canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* ê¸°ì¡´ ì´ë¯¸ì§€ ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ */
        .comparison-container {
            position: relative;
            width: 80vw;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            overflow: hidden;
            z-index: 50;
            margin-top: 50px;
        }
        .comparison-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
        }
        .image-before {
            z-index: 10;
            clip-path: inset(0 50% 0 0);
        }
        .image-after {
            z-index: 1;
        }
        .slider-handle {
    position: absolute;
    z-index: 20;
    top: 0;
    left: 50%;
    width: 0px; 
    height: 100%;
    
    /* ğŸ’¡ ë³€ê²½: ê·¸ë¦¼ì(ë¹›)ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ë°°ê²½ìƒ‰ì€ íˆ¬ëª…í•˜ê²Œ */
    background-color: transparent; 
    
    cursor: ew-resize;
    transform: translateX(-50%);
    transition: left 0.15s ease-out; 
}
        .slider-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: white;
            border-radius: 50%;
            display: grid;
            place-items: center;
            font-weight: bold;
            font-size: 1.2rem;
            box-shadow: 0 0 20px rgba(255, 236, 197, 0.8);
        }
        
        ::selection {
            background: transparent; 
            color: inherit;
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <div class="comparison-container" id="my-container">
        <img class="image-before" src="web-source/4.jpg" alt="Before"> 
        <img class="image-after" src="web-source/4-1.jpg" alt="After">
        <div class="slider-handle" id="my-slider"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('my-container');
            const slider = document.getElementById('my-slider');
            const imageBefore = container.querySelector('.image-before');

            let isDragging = false;

            const startDrag = (e) => { isDragging = true; };
            const stopDrag = () => { isDragging = false; };

            const onDrag = (e) => {
                if (!isDragging) return;
                let clientX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
                if (clientX === undefined) return;

                const rect = container.getBoundingClientRect();
                let newX = clientX - rect.left;
                if (newX < 0) newX = 0;
                if (newX > rect.width) newX = rect.width;
                const percentage = (newX / rect.width) * 100;
                slider.style.left = percentage + '%';
                imageBefore.style.clipPath = `inset(0 ${100 - percentage}% 0 0)`;
            };

            slider.addEventListener('mousedown', startDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('mousemove', onDrag);
            slider.addEventListener('touchstart', startDrag, { passive: true });
            document.addEventListener('touchend', stopDrag, { passive: true });
            document.addEventListener('touchmove', onDrag, { passive: true });
        });
    </script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    
        const container = document.getElementById('three-container');
        const width = container.clientWidth;
        const height = container.clientHeight;
    
        // --- 1. ê¸°ë³¸ ì„¤ì • ---
        const scene = new THREE.Scene();
        // ì¹´ë©”ë¼ FOVë¥¼ 20ë„ë¡œ ì„¤ì •í•˜ì—¬ ëª¨ë¸ì„ í¬ê²Œ ë³´ì´ê²Œ í•¨
        const camera = new THREE.PerspectiveCamera(20, width / height, 0.1, 100); 
        camera.position.set(0, 0, 30); 
    
        const renderer = new THREE.WebGLRenderer({ antialias: true }); 
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        // ë°°ê²½ìƒ‰ì„ í°ìƒ‰ìœ¼ë¡œ ì„¤ì •
        renderer.setClearColor(0xffffff); 
        
        // í™˜ê²½ ë§µ ì„¤ì •ì„ ìœ„í•œ íë¸Œ ì¹´ë©”ë¼
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, { 
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
        scene.add(cubeCamera); 
    
        // --- 2. ë¹› ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x644F1F, 2); 
        directionalLight.position.set(-0.5, 1, 1);
        scene.add(directionalLight);
    
        // --- 3. ì»¤ìŠ¤í…€ 3D ëª¨ë¸ ë¡œë“œ ---
        const gltfLoader = new GLTFLoader();
        let controller; // ëª¨ë¸ì„ ê°ì‹¸ íšŒì „ì‹œí‚¤ëŠ” ì—­í• ì„ í•  Object3D
        
        gltfLoader.load(
            // ì£¼ì˜: ì´ íŒŒì¼ ê²½ë¡œëŠ” ì‹¤ì œ í™˜ê²½ì— ë§ê²Œ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.
            'model2.glb', 
            (gltf) => {
                const model = gltf.scene;
    
                // í™˜ê²½ ë§µ ì ìš© (ëª¨ë¸ì˜ ë©”íƒˆë¦­/ë°˜ì‚¬ê´‘ íš¨ê³¼ë¥¼ ìœ„í•´)
                model.traverse((child) => {
                    if (child.isMesh) {
                        const originalMaterial = child.material;
                        if (originalMaterial.isMeshStandardMaterial) {
                            originalMaterial.envMap = cubeRenderTarget.texture; 
                            originalMaterial.needsUpdate = true;
                        }
                    }
                });
    
                // ëª¨ë¸ í¬ê¸° ë° ìœ„ì¹˜ ë³´ì • (ë·°í¬íŠ¸ì— ë§ê²Œ í¬ê¸° ì¡°ì •)
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const maxAxis = Math.max(size.x, size.y, size.z);
                const targetScale = 5.0 / maxAxis; 
                const scaleMultiplier = 5; // ëª¨ë¸ í¬ê¸°ë¥¼ ë” í‚¤ìš°ê¸° ìœ„í•œ ë°°ìˆ˜
                const finalScale = targetScale * scaleMultiplier;
    
                model.scale.set(finalScale, finalScale, finalScale);
                
                // ëª¨ë¸ì„ ì¤‘ì•™ì— ìœ„ì¹˜
                model.position.x -= center.x * finalScale;
                model.position.y -= center.y * finalScale;
                model.position.z -= center.z * finalScale; 
    
                controller = new THREE.Object3D();
                controller.add(model);
                scene.add(controller);
                
                controller.position.set(0, 0, 0); 
            },
            undefined,
            (error) => {
                console.error('ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error);
            }
        );
        
        // --- 4. ë§ˆìš°ìŠ¤ ì›€ì§ì„ ê°ì§€ ë° ì• ë‹ˆë©”ì´ì…˜ (íšŒì „) ---
        let mouseX = 0;
        let mouseY = 0;
    
        function onMouseMove(event) {
            // ì „ì²´ ì°½ í¬ê¸°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ -1 ~ 1ë¡œ ì •ê·œí™”
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1; 
        }
        window.addEventListener('mousemove', onMouseMove); 
    
        function animate() {
            requestAnimationFrame(animate);
    
            if (controller) {
                // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë”°ë¼ íšŒì „ ëª©í‘œ ì„¤ì • (ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„ì„ ìœ„í•´ ë³´ê°„ ì ìš©)
                const targetLogoRotY = mouseX * 0.2; 
                const targetLogoRotX = -mouseY * 0.2;
    
                // ë¶€ë“œëŸ¬ìš´ íšŒì „ì„ ìœ„í•œ ë³´ê°„
                controller.rotation.y += (targetLogoRotY - controller.rotation.y) * 0.1;
                controller.rotation.x += (targetLogoRotX - controller.rotation.x) * 0.1;
    
                // í™˜ê²½ ë§µ ì—…ë°ì´íŠ¸
                controller.visible = false;
                cubeCamera.update(renderer, scene); 
                controller.visible = true;
            }
    
            renderer.render(scene, camera);
        }
        animate();
    
        // --- 5. ì°½ í¬ê¸° ë³€ê²½ ëŒ€ì‘ (ë°˜ì‘í˜•ì˜ í•µì‹¬) ---
        window.addEventListener('resize', () => {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;
            
            // ìº”ë²„ìŠ¤ í¬ê¸° ì—…ë°ì´íŠ¸
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        });
    </script>
</body>
</html>

