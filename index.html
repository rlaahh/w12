<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reframed</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. Í∏∞Î≥∏ ÏÑ§Ï†ï ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); 

        // yawObject: Ïπ¥Î©îÎùºÎ•º Ï¢åÏö∞(YÏ∂ï)Î°ú ÌöåÏ†ÑÏãúÌÇ§Îäî Î∂ÄÎ™® Í∞ùÏ≤¥
        const yawObject = new THREE.Object3D();
        yawObject.position.set(0, 0, 0);
        yawObject.add(camera); 
        scene.add(yawObject);  
        
        camera.position.set(0, 0, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        document.body.appendChild(renderer.domElement);

        // ÌôòÍ≤Ω Îßµ (Î∞òÏÇ¨) ÏÑ§Ï†ï
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, { 
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
        scene.add(cubeCamera); 

        // --- 2. Îπõ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x644F1F, 1.5); 
        directionalLight.position.set(-0.5, 1, 1.8);
        scene.add(directionalLight);

        // --- 3. Ïù¥ÎØ∏ÏßÄ Ìå®ÎÑê ÏÉùÏÑ± ---
        const imageUrls = [];
        const totalImageCount = 30; 
        for (let i = 1; i <= totalImageCount; i++) {
            imageUrls.push(`web-source/${i}.jpg`); 
        }

        const textureLoader = new THREE.TextureLoader();

        const sphereRadius = 6; 
        const numLayers = 5; 
        const imagesPerLayer = Math.ceil(totalImageCount / numLayers); 
        const layerSpacingAngle = Math.PI * 0.10;
        
        const phiLayers = [
            Math.PI * 0.5 - layerSpacingAngle * 2,
            Math.PI * 0.5 - layerSpacingAngle * 1,
            Math.PI * 0.5,
            Math.PI * 0.5 + layerSpacingAngle * 1,
            Math.PI * 0.5 + layerSpacingAngle * 2
        ];
        
        const imageMeshes = [];
        const imageUrlsMap = new Map(); // Mesh Í∞ùÏ≤¥ÏôÄ Ïù¥ÎèôÌï† URL Îß§Ìïë

        imageUrls.forEach((url, index) => {
            textureLoader.load(url, (texture) => {
                const aspectRatio = texture.image.width / texture.image.height;
                const maxDimension = 1.5; 
                let planeWidth, planeHeight;

                if (aspectRatio >= 1) { 
                    planeWidth = maxDimension;
                    planeHeight = planeWidth / aspectRatio; 
                } else { 
                    planeHeight = maxDimension;
                    planeWidth = planeHeight * aspectRatio; 
                }

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                
                // üí° [ÏàòÏ†ïÎêú Î°úÏßÅ] Î™®Îì† Ïù¥ÎØ∏ÏßÄÏóê ÎåÄÌï¥ ÌååÏùºÎ™Ö Í∏∞Î∞òÏúºÎ°ú URL ÏÑ§Ï†ï
                const fileNameMatch = url.match(/(\d+)\.jpg$/);
                let targetPage;

                if (fileNameMatch && fileNameMatch[1]) {
                    // Ïòà: web-source/9.jpg -> 9.html
                    const imageNumber = fileNameMatch[1];
                    targetPage = `${imageNumber}.html`;
                } else {
                    // Ï†ïÍ∑ú ÌëúÌòÑÏãù Ìå®ÌÑ¥Ïù¥ ÏùºÏπòÌïòÏßÄ ÏïäÏùÑ Í≤ΩÏö∞ ÎåÄÎπÑ
                    targetPage = `page_default.html`; 
                    console.warn(`ÌååÏùºÎ™ÖÏùÑ Ï∂îÏ∂úÌï† Ïàò ÏóÜÏñ¥ Í∏∞Î≥∏ URLÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§: ${url}`);
                }

                imageUrlsMap.set(mesh, targetPage); 
                imageMeshes.push(mesh); 

                const layerIndex = Math.floor(index / imagesPerLayer);
                const phi = phiLayers[layerIndex];
                const indexInLayer = index % imagesPerLayer;
                
                let startOffset = 0;
                if (layerIndex % 2 !== 0) { 
                    startOffset = (Math.PI / imagesPerLayer) / 2;
                }
                
                const angleIncrement = (indexInLayer / imagesPerLayer) * Math.PI;
                const theta_final_corrected = angleIncrement + startOffset + (Math.PI / 1.8); 

                mesh.position.setFromSphericalCoords(sphereRadius, phi, theta_final_corrected);
                
                mesh.lookAt(0, 0, 0); 

                mesh.renderOrder = 0; 
                scene.add(mesh);
            });
        });

        // --- 4. Ïª§Ïä§ÌÖÄ 3D Î™®Îç∏ Î°úÎìú ---
        const gltfLoader = new GLTFLoader();
        let controller; 
        
        gltfLoader.load(
            'model2.glb', 
            (gltf) => {
                const model = gltf.scene;

                // Ïû¨Ïßà Î∞è ÍπäÏù¥ ÌÖåÏä§Ìä∏ ÏÑ§Ï†ï (depthTest, depthWrite Í∏∞Î≥∏Í∞í Ïú†ÏßÄ)
                model.traverse((child) => {
                    if (child.isMesh) {
                        const originalMaterial = child.material;
                        if (originalMaterial.isMeshStandardMaterial) {
                            originalMaterial.envMap = cubeRenderTarget.texture; 
                            originalMaterial.needsUpdate = true;
                        }
                        child.renderOrder = 1; 
                    }
                });

                // ÌÅ¨Í∏∞ Î∞è ÏúÑÏπò Î≥¥Ï†ï
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const maxAxis = Math.max(size.x, size.y, size.z);
                const targetScale = 2.0 / maxAxis; 
                const scaleMultiplier = 2; 
                const finalScale = targetScale * scaleMultiplier;

                model.scale.set(finalScale, finalScale, finalScale);
                model.position.x -= center.x * finalScale;
                model.position.y -= center.y * finalScale;
                model.position.z -= center.z * finalScale; 

                // Ïª®Ìä∏Î°§Îü¨ Ïª®ÌÖåÏù¥ÎÑà ÏÑ§Ï†ï
                const container = new THREE.Object3D();
                container.add(model);
                container.position.set(0, 0, -5); 

                controller = container; 
                camera.add(controller);
                console.log("Î™®Îç∏ Î°úÎìú ÏôÑÎ£å"); 
            },
            undefined,
            (error) => {
                console.error('Î™®Îç∏ Î°úÎìú Ïã§Ìå®:', error);
            }
        );
        
        // --- 5. ÎßàÏö∞Ïä§ ÏúÑÏπò Ï∂îÏ†Å Î∞è Raycaster ---
        const raycaster = new THREE.Raycaster();
        const mouseVector = new THREE.Vector2();
        let mouseX = 0;
        let mouseY = 0;
        
        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
            mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouseVector, camera);

            const intersects = raycaster.intersectObjects(imageMeshes);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const targetUrl = imageUrlsMap.get(intersectedObject);

                if (targetUrl) {
                    console.log(`ÌéòÏù¥ÏßÄ Ïù¥Îèô: ${targetUrl}`);
                    window.location.href = targetUrl; 
                }
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);

        // --- 6. Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ (Î∂ÄÎìúÎü¨Ïö¥ ÏõÄÏßÅÏûÑ Íµ¨ÌòÑ) ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Ïπ¥Î©îÎùº(ÏãúÏÑ†) ÌöåÏ†Ñ
            const targetCameraRotY = -mouseX * (Math.PI / 4); 
            const targetCameraRotX = mouseY * (Math.PI / 6); 

            yawObject.rotation.y += (targetCameraRotY - yawObject.rotation.y) * 0.05;
            camera.rotation.x += (targetCameraRotX - camera.rotation.x) * 0.05;


            // 2. Î°úÍ≥†(Î™®Îç∏) ÌöåÏ†Ñ
            if (controller) {
                const targetLogoRotY = mouseX * 0.5; 
                const targetLogoRotX = -mouseY * 0.5;

                controller.rotation.y += (targetLogoRotY - controller.rotation.y) * 0.1;
                controller.rotation.x += (targetLogoRotX - controller.rotation.x) * 0.1;

                // 3. ÌôòÍ≤Ω Îßµ ÏóÖÎç∞Ïù¥Ìä∏ (Î∞òÏÇ¨ Ìö®Í≥º)
                controller.visible = false;
                
                cubeCamera.position.copy(yawObject.position);
                cubeCamera.rotation.copy(yawObject.rotation); 
                
                cubeCamera.update(renderer, scene); 
                controller.visible = true;
            }

            renderer.render(scene, camera);
        }
        animate();

        // --- 7. Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω ÎåÄÏùë ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>